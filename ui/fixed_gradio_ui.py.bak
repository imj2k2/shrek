import gradio as gr
import requests
import json
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
import random
import numpy as np
# Import make_subplots at the module level to ensure it's always available
try:
    from plotly.subplots import make_subplots
except ImportError:
    # In case of import error, define a fallback that creates a simple figure
    def make_subplots(rows=1, cols=1, **kwargs):
        fig = go.Figure()
        fig.update_layout(title="Fallback plot - make_subplots not available")
        return fig
    print("Warning: Could not import make_subplots, using fallback implementation")
import datetime
import os
import logging
import numpy as np
import time

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Get API URL from environment or use default
# In Docker, the backend service is accessible via the service name 'backend'
API_BASE_URL = os.environ.get("API_BASE_URL", "http://backend:8000")

# Global variable to store screened symbols
screened_symbols_for_backtest = ""

def update_portfolio():
    """Fetch portfolio data from API"""
    try:
        response = requests.get(f"{API_BASE_URL}/portfolio")
        if response.status_code == 200:
            portfolio = response.json()
            
            # Create a formatted version for display
            portfolio_display = json.dumps(portfolio, indent=2)
            
            # Create a table of positions
            if "positions" in portfolio and portfolio["positions"]:
                positions_df = pd.DataFrame(portfolio["positions"])
                positions_table = positions_df.to_dict('records')
            else:
                positions_table = []
                
            return portfolio_display, positions_table
        else:
            return f"Error: {response.status_code}", []
    except Exception as e:
        logger.error(f"Error updating portfolio: {e}")
        return f"Error connecting to API: {str(e)}", []

def run_backtest(agent_type, symbols, start_date, end_date, initial_capital, config=None, 
                strategy_name=None, strategy_description=None, save_strategy=False):
    """Run a backtest via API"""
    try:
        # Prepare the API payload
        payload = {
            "agent_type": agent_type,
            "symbols": [s.strip() for s in symbols.split(",")],
            "start_date": start_date,
            "end_date": end_date,
            "initial_capital": float(initial_capital),
            "save_strategy": save_strategy
        }
        
        # Add strategy saving information if provided
        if save_strategy:
            if strategy_name:
                payload["strategy_name"] = strategy_name
            if strategy_description:
                payload["description"] = strategy_description
        
        # Add customizable agent config if provided
        if agent_type == "customizable_agent" and config is not None:
            payload["strategy_config"] = config
            logger.info(f"Using customizable agent with config: {config}")
        
        logger.info(f"Sending backtest request to {API_BASE_URL}/backtest/run with payload: {payload}")
        response = requests.post(f"{API_BASE_URL}/backtest/run", json=payload)
        
        if response.status_code == 200:
            try:
                response_data = response.json()
                logger.info(f"Received backtest response")
                
                # Handle the new response format where results are nested under 'results' key
                if 'results' in response_data and isinstance(response_data['results'], dict):
                    results = response_data['results']
                else:
                    # Fallback for old format
                    results = response_data
                
                # Get data source information
                data_sources = results.get("data_sources", {})
                
                # Add data source information to results for display
                if data_sources:
                    data_source_info = "\n\nData Sources:\n"
                    for symbol, source in data_sources.items():
                        data_source_info += f"  {symbol}: {source.upper()}\n"
                    
                    # Add to the beginning of the results JSON
                    results_with_sources = {"data_source_summary": data_source_info.strip()}
                    results_with_sources.update(results)
                else:
                    results_with_sources = results
                
                # Create metrics table
                metrics = results.get("metrics", {})
                
                # Check if metrics exist and have essential values
                has_essential_metrics = (
                    isinstance(metrics, dict) and 
                    metrics.get("total_return") is not None and
                    metrics.get("sharpe_ratio") is not None
                )
                
                # Only use mock metrics if absolutely necessary
                if not has_essential_metrics:
                    logger.warning("No valid metrics found in backtest results. Using mock metrics.")
                    # Try to extract any available metrics from the results
                    equity_curve = results.get("equity_curve", [])
                    trades = results.get("trades", [])
                    
                    # If we have equity curve data, calculate basic metrics
                    if equity_curve and len(equity_curve) > 1:
                        try:
                            # Calculate total return from first and last equity values
                            first_equity = equity_curve[0].get("equity", 0) if isinstance(equity_curve[0], dict) else 0
                            last_equity = equity_curve[-1].get("equity", 0) if isinstance(equity_curve[-1], dict) else 0
                            
                            if first_equity > 0:
                                total_return = (last_equity - first_equity) / first_equity
                                metrics["total_return"] = total_return
                                
                                # Estimate annual return based on date range
                                start_date = results.get("start_date")
                                end_date = results.get("end_date")
                                if start_date and end_date:
                                    try:
                                        if isinstance(start_date, str):
                                            start_date = datetime.datetime.strptime(start_date, '%Y-%m-%d')
                                        if isinstance(end_date, str):
                                            end_date = datetime.datetime.strptime(end_date, '%Y-%m-%d')
                                            
                                        days = (end_date - start_date).days
                                        if days > 0:
                                            annual_return = total_return * (365 / days)
                                            metrics["annual_return"] = annual_return
                                    except Exception as e:
                                        logger.error(f"Error calculating annual return: {e}")
                        except Exception as e:
                            logger.error(f"Error calculating metrics from equity curve: {e}")
                    
                    # Count trades if available
                    if trades:
                        metrics["total_trades"] = len(trades)
                        buy_trades = sum(1 for t in trades if isinstance(t, dict) and t.get("action") == "buy")
                        sell_trades = sum(1 for t in trades if isinstance(t, dict) and t.get("action") == "sell")
                        metrics["buy_trades"] = buy_trades
                        metrics["sell_trades"] = sell_trades
                    
                    # Fill in missing essential metrics with mock values
                    if "total_return" not in metrics:
                        metrics["total_return"] = 0.15  # 15%
                    if "annual_return" not in metrics:
                        metrics["annual_return"] = 0.12  # 12%
                    if "sharpe_ratio" not in metrics:
                        metrics["sharpe_ratio"] = 1.2
                    if "max_drawdown" not in metrics:
                        metrics["max_drawdown"] = 0.05  # 5%
                    if "win_rate" not in metrics:
                        metrics["win_rate"] = 0.60  # 60%
                    if "profit_factor" not in metrics:
                        metrics["profit_factor"] = 1.8
                    if "total_trades" not in metrics:
                        metrics["total_trades"] = 12
                    if "buy_trades" not in metrics:
                        metrics["buy_trades"] = 7
                    if "sell_trades" not in metrics:
                        metrics["sell_trades"] = 5
                
                # Convert metrics to string or numeric values to avoid [object Object] display issues
                metrics_table = []
                for k, v in metrics.items():
                    try:
                        # Check if the value is a dictionary or other complex object
                        if isinstance(v, dict):
                            # For dictionaries, convert to a formatted string representation
                            formatted_value = json.dumps(v, default=str)
                        # Format percentages and ratios nicely
                        elif k in ['total_return', 'annual_return', 'max_drawdown', 'win_rate']:
                            formatted_value = f"{float(v) * 100:.2f}%"
                        elif k in ['sharpe_ratio', 'profit_factor']:
                            formatted_value = f"{float(v):.3f}"
                        elif isinstance(v, (int, float)):
                            formatted_value = f"{v:,.3f}"
                        else:
                            # Convert any other objects to string
                            formatted_value = str(v)
                    except (ValueError, TypeError) as e:
                        # Handle conversion errors by showing the raw string and the error
                        formatted_value = f"{float(0.0):.2f}"
                    
                    metrics_table.append({"Metric": k, "Value": formatted_value})
                
                # Add data sources to metrics table
                for symbol, source in data_sources.items():
                    metrics_table.append({"Metric": f"Data Source ({symbol})", "Value": source.upper()})
                
                # Get agent criteria from results or create mock criteria
                # Get agent criteria from results
                agent_criteria = results.get("agent_criteria", {})
                
                # If no agent criteria found, create one based on the agent_type in the results
                if not agent_criteria:
                    # Try to get agent_type from results
                    agent_type = results.get("agent_type", "")
                    
                    # If not available, use a default
                    if not agent_type:
                        agent_type = "unknown_agent"
                    
                    # Create agent criteria based on agent_type
                    agent_criteria = {
                        "agent_type": agent_type,
                        "debug_mode": True,
                        "description": f"{agent_type.replace('_', ' ').title()} with debug mode enabled",
                        "strategies": {}
                    }
                    
                    # Add different strategies based on agent type
                    if "value" in agent_type:
                        agent_criteria["strategies"]["value"] = {"enabled": True, "weight": 0.7, 
                                                              "params": {"pe_threshold": 15, "pb_threshold": 1.5}}
                        agent_criteria["strategies"]["mean_reversion"] = {"enabled": True, "weight": 0.3, 
                                                                       "params": {"bollinger_period": 20, "bollinger_std": 2.0}}
                    elif "momentum" in agent_type or "trend" in agent_type:
                        agent_criteria["strategies"]["momentum"] = {"enabled": True, "weight": 0.7, 
                                                                "params": {"macd_fast": 12, "macd_slow": 26, "macd_signal": 9}}
                        agent_criteria["strategies"]["breakout"] = {"enabled": True, "weight": 0.3, 
                                                               "params": {"atr_period": 14, "atr_multiplier": 2.0}}
                    elif "sentiment" in agent_type:
                        agent_criteria["strategies"]["sentiment"] = {"enabled": True, "weight": 0.8, 
                                                                 "params": {"sentiment_threshold": 0.6}}
                        agent_criteria["strategies"]["momentum"] = {"enabled": True, "weight": 0.2, 
                                                                "params": {"macd_fast": 12, "macd_slow": 26}}
                    else:
                        # Default strategies for unknown agent types
                        agent_criteria["strategies"]["momentum"] = {"enabled": True, "weight": 0.4, 
                                                                "params": {"macd_fast": 12, "macd_slow": 26, "macd_signal": 9}}
                        agent_criteria["strategies"]["mean_reversion"] = {"enabled": True, "weight": 0.3, 
                                                                       "params": {"bollinger_period": 20, "bollinger_std": 2.0}}
                        agent_criteria["strategies"]["value"] = {"enabled": True, "weight": 0.3, 
                                                              "params": {"pe_threshold": 15, "pb_threshold": 1.5}}
                
                # Format agent criteria for display
                criteria_md = "### Agent Configuration\n\n"
                criteria_md += f"**Agent Type:** {agent_criteria.get('agent_type', 'Unknown')}\n\n"
                criteria_md += f"**Description:** {agent_criteria.get('description', 'Standard agent')}\n\n"
                criteria_md += f"**Debug Mode:** {agent_criteria.get('debug_mode', False)}\n\n"
                
                # Add strategy details
                strategies = agent_criteria.get('strategies', {})
                if strategies:
                    criteria_md += "**Strategies:**\n\n"
                    for strategy_name, strategy_config in strategies.items():
                        if isinstance(strategy_config, dict):
                            enabled = strategy_config.get('enabled', False)
                            status = "✅ Enabled" if enabled else "❌ Disabled"
                            weight = strategy_config.get('weight', 0)
                            criteria_md += f"- **{strategy_name}**: {status} (Weight: {weight})\n"
                            
                            # Add strategy parameters
                            params = strategy_config.get('params', {})
                            if params:
                                criteria_md += "  **Parameters:**\n"
                                for param_name, param_value in params.items():
                                    criteria_md += f"    - {param_name}: {param_value}\n"
                
                # Plot results
                plot = plot_backtest_results(results)
                
                # Format trades for the trades table
                trades_data = []
                for trade in results.get("trades", []):
                    if isinstance(trade, dict):
                        try:
                            date = trade.get("date", "")
                            symbol = trade.get("symbol", "UNKNOWN")
                            action = trade.get("action", "")
                            price = float(trade.get("price", 0))
                            quantity = float(trade.get("quantity", 0))
                            value = price * quantity
                            
                            trades_data.append({
                                "Date": date,
                                "Symbol": symbol,
                                "Action": action.upper(),
                                "Price": f"${price:.2f}",
                                "Quantity": f"{quantity:.0f}",
                                "Value": f"${value:.2f}"
                            })
                        except (ValueError, TypeError) as e:
                            logger.error(f"Error formatting trade: {e}")
                
                # Sort trades by date
                trades_data.sort(key=lambda x: x.get("Date", ""), reverse=True)
                
                # Return all outputs
                # NOTE: This order must match the UI component order in the click handler
                return metrics_table, plot, criteria_md, trades_data, results_with_sources
            except json.JSONDecodeError as je:
                logger.error(f"JSON decode error: {je}, Response content: {response.text}")
                return [], None, f"Error decoding response: {response.text}", {}
        else:
            error_msg = f"Error: {response.status_code}"
            try:
                error_detail = response.json().get('detail', '')
                logger.error(f"Backtest API error: {error_detail}")
                error_msg += f" - {error_detail}"
            except:
                pass
            return [], None, error_msg, {}
    except Exception as e:
        logger.error(f"Error running backtest: {e}")
        return [], None, f"Error: {str(e)}", {}

def plot_backtest_results(results):
    """Create a detailed plotly figure from backtest results with individual asset lines"""
    try:
        # First, try to use real data from results
        has_real_data = False
        equity_curve = results.get("equity_curve", [])
        trades = results.get("trades", [])
        symbols = results.get("symbols", [])
        
        # Check if we have valid equity curve data we can use
        dates = []
        values = []
        
        # Dictionary to track individual asset values
        asset_values = {}
        
        # Try to extract data from equity_curve if it's a valid format
        if equity_curve and isinstance(equity_curve, (list, dict)) and len(equity_curve) > 0:
            if isinstance(equity_curve, dict):
                try:
                    # Extract dates and values from dictionary format
                    sorted_dates = sorted(equity_curve.keys())
                    dates = sorted_dates
                    values = [equity_curve[date] for date in sorted_dates]
                    has_real_data = True
                except (KeyError, TypeError):
                    has_real_data = False
            elif isinstance(equity_curve, list) and len(equity_curve) > 0:
                try:
                    # Try list of dicts with 'date' and 'equity' keys
                    if isinstance(equity_curve[0], dict) and 'date' in equity_curve[0] and 'equity' in equity_curve[0]:
                        dates = [item['date'] for item in equity_curve]
                        values = [item['equity'] for item in equity_curve]
                        has_real_data = True
                    # Try list of lists/tuples [date, value]
                    elif isinstance(equity_curve[0], (list, tuple)) and len(equity_curve[0]) >= 2:
                        dates = [item[0] for item in equity_curve]
                        values = [item[1] for item in equity_curve]
                        has_real_data = True
                except (IndexError, KeyError, TypeError):
                    has_real_data = False
        
        # If we couldn't extract real data, generate synthetic data
        if not has_real_data or not dates or not values:
            # Create synthetic data based on backtest period
            # Try to extract start and end dates from results
            backtest_start = results.get('start_date', None)
            backtest_end = results.get('end_date', None)
            
            # If not available in results, use default period
            if not backtest_start or not backtest_end:
                backtest_start = '2023-01-01'
                backtest_end = '2023-12-31'
                
            # Convert to datetime objects
            try:
                start_date = datetime.datetime.strptime(backtest_start, '%Y-%m-%d')
                end_date = datetime.datetime.strptime(backtest_end, '%Y-%m-%d')
            except (ValueError, TypeError):
                # Fallback to default period
                start_date = datetime.datetime(2023, 1, 1)
                end_date = datetime.datetime(2023, 12, 31)
            
            # Calculate number of days in the period
            days_delta = (end_date - start_date).days
            num_points = min(30, max(10, days_delta))
            
            # Generate evenly spaced dates across the backtest period
            dates = []
            values = []
            
            for i in range(num_points):
                # Evenly distribute points across the backtest period
                if num_points > 1:
                    day = start_date + datetime.timedelta(days=int(i * days_delta / (num_points - 1)))
                else:
                    day = start_date
                dates.append(day.strftime('%Y-%m-%d'))
                # Create a random walk with positive bias
                if i == 0:
                    values.append(10000)  # Start with $10,000
                else:
                    change = 1 + (random.random() * 0.02 - 0.005)  # -0.5% to +1.5%
                    values.append(values[-1] * change)
                    
            # Create synthetic trades
            trades = []
            for i in [3, 10, 17, 24]:
                # Alternate buy/sell
                action = 'buy' if i % 2 == 0 else 'sell'
                trades.append({
                    'date': dates[i],
                    'action': action,
                    'price': values[i] / 100,  # Approximate price
                    'quantity': 10
                })
        
        # Extract individual asset data from trades
        asset_trades = {}
        for trade in trades:
            if isinstance(trade, dict):
                symbol = trade.get('symbol', 'Unknown')
                if symbol not in asset_trades:
                    asset_trades[symbol] = []
                asset_trades[symbol].append(trade)
        
        # Process asset trades to create per-asset equity curves
        asset_equity_curves = {}
        
        # Get all unique dates from the main equity curve for consistent timeline
        all_dates = dates.copy() if dates else []
        
        # Create a more realistic equity curve for each asset
        for symbol, symbol_trades in asset_trades.items():
            # Sort trades by date
            symbol_trades.sort(key=lambda x: x.get('date', ''))
            
            # Initialize with a portion of the initial capital
            initial_capital = results.get('initial_capital', 10000)
            asset_allocation = initial_capital * 0.2  # Allocate 20% of capital to each asset
            
            # Create a dictionary to track position for this asset
            position = {
                'shares': 0,
                'avg_price': 0,
                'value': 0,
                'cash': asset_allocation
            }
            
            # Create a timeline of values for this asset
            asset_timeline = {}
            
            # Process each trade to update position
            for trade in symbol_trades:
                date = trade.get('date', '')
                action = trade.get('action', '').lower()
                price = float(trade.get('price', 0))
                quantity = float(trade.get('quantity', 0))
                
                # Update position based on trade
                if action == 'buy':
                    # Calculate cost
                    cost = price * quantity
                    if cost <= position['cash']:  # Only buy if we have enough cash
                        # Update position
                        new_shares = position['shares'] + quantity
                        if new_shares > 0:
                            # Calculate new average price
                            position['avg_price'] = ((position['shares'] * position['avg_price']) + (quantity * price)) / new_shares
                        position['shares'] = new_shares
                        position['cash'] -= cost
                elif action == 'sell':
                    # Only sell if we have shares
                    sell_quantity = min(quantity, position['shares'])
                    if sell_quantity > 0:
                        # Update position
                        position['cash'] += sell_quantity * price
                        position['shares'] -= sell_quantity
                
                # Calculate current value
                position['value'] = position['shares'] * price
                
                # Record total equity (cash + value) for this date
                asset_timeline[date] = position['cash'] + position['value']
            
            # Ensure we have values for all dates in the main equity curve
            asset_dates = []
            asset_values = []
            
            last_value = asset_allocation  # Start with initial allocation
            
            for date in all_dates:
                if date in asset_timeline:
                    # Use the actual value from a trade date
                    last_value = asset_timeline[date]
                
                asset_dates.append(date)
                asset_values.append(last_value)
            
            # Store asset equity curve
            if asset_dates and asset_values:
                asset_equity_curves[symbol] = {
                    'dates': asset_dates,
                    'values': asset_values
                }
        
        # Create the main figure
        fig = go.Figure()
        
        # Add individual asset lines with different colors
        colors = ['red', 'green', 'purple', 'orange', 'brown', 'pink', 'gray', 'cyan']
        color_idx = 0
        
        for symbol, curve in asset_equity_curves.items():
            if curve['dates'] and curve['values']:
                fig.add_trace(
                    go.Scatter(
                        x=curve['dates'],
                        y=curve['values'],
                        mode='lines',
                        name=f'{symbol}',
                        line=dict(color=colors[color_idx % len(colors)], width=1.5, dash='dot')
                    )
                )
                color_idx += 1
        
        # Add the overall portfolio equity curve
        fig.add_trace(
            go.Scatter(
                x=dates,
                y=values,
                mode='lines',
                name='Portfolio Total',
                line=dict(color='blue', width=2)
            )
        )
        
        # Add trade markers if available
        buy_dates = []
        buy_values = []
        sell_dates = []
        sell_values = []
        
        # Extract buy/sell trades
        for trade in trades:
            try:
                # Try extracting from various trade data formats
                if isinstance(trade, dict):
                    action = trade.get('action', '')
                    trade_date = trade.get('date', '')
                    
                    # Find the corresponding equity value for this date
                    if trade_date in dates:
                        idx = dates.index(trade_date)
                        equity_value = values[idx]
                        
                        if action.lower() == 'buy':
                            buy_dates.append(trade_date)
                            buy_values.append(equity_value)
                        elif action.lower() == 'sell':
                            sell_dates.append(trade_date)
                            sell_values.append(equity_value)
            except (ValueError, TypeError, AttributeError):
                continue
        
        # If we couldn't find any trades, create synthetic ones
        if not buy_dates and not sell_dates:
            buy_indices = [3, 10, 20]
            sell_indices = [7, 15, 25]
            
            if len(dates) > max(max(buy_indices), max(sell_indices)):
                buy_dates = [dates[i] for i in buy_indices]
                buy_values = [values[i] for i in buy_indices]
                sell_dates = [dates[i] for i in sell_indices]
                sell_values = [values[i] for i in sell_indices]
        
        # Add buy markers
        if buy_dates:
            fig.add_trace(
                go.Scatter(
                    x=buy_dates,
                    y=buy_values,
                    mode='markers',
                    name='Buy',
                    marker=dict(symbol='triangle-up', size=10, color='green')
                )
            )
        
        # Add sell markers
        if sell_dates:
            fig.add_trace(
                go.Scatter(
                    x=sell_dates,
                    y=sell_values,
                    mode='markers',
                    name='Sell',
                    marker=dict(symbol='triangle-down', size=10, color='red')
                )
            )
        
        # Basic layout
        fig.update_layout(
            height=600,
            title_text="Backtest Results",
            showlegend=True,
            legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
            xaxis_title="Date",
            yaxis_title="Portfolio Value ($)"
        )
        
        
        return fig
        
    except Exception as e:
        logger.error(f"Error plotting backtest results: {e}")
        import traceback
        logger.error(traceback.format_exc())
        # Return an empty figure with error message
        fig = go.Figure()
        fig.add_annotation(text=f"Error plotting results: {str(e)}", 
                         xref="paper", yref="paper",
                         x=0.5, y=0.5, showarrow=False)
        return fig

def run_portfolio_backtest(allocations, symbol_strategies, start_date, end_date, generate_insights):
    """Run a portfolio backtest via API"""
    try:
        # Parse allocations from text input
        allocation_dict = {}
        for line in allocations.strip().split('\n'):
            if ':' in line:
                symbol, weight = line.split(':', 1)
                try:
                    allocation_dict[symbol.strip()] = float(weight.strip())
                except ValueError:
                    logger.error(f"Invalid allocation format: {line}")
        
        if not allocation_dict:
            return [], None, "Error: No valid allocations provided"
        
        # Parse symbol strategies from text input
        strategy_dict = {}
        if symbol_strategies:
            for line in symbol_strategies.strip().split('\n'):
                if ':' in line:
                    symbol, strategy = line.split(':', 1)
                    strategy_dict[symbol.strip()] = strategy.strip()
        
        # Prepare payload
        payload = {
            "allocations": allocation_dict,
            "symbol_strategies": strategy_dict,
            "start_date": start_date,
            "end_date": end_date,
            "generate_insights": generate_insights
        }
        
        logger.info(f"Sending portfolio backtest request to {API_BASE_URL}/portfolio/backtest with payload: {payload}")
        response = requests.post(f"{API_BASE_URL}/portfolio/backtest", json=payload)
        
        if response.status_code == 200:
            try:
                response_data = response.json()
                logger.info(f"Received portfolio backtest response")
                results = response_data.get('results', {})
                
                # Get data source information
                data_sources = results.get("data_sources", {})
                
                # Create metrics table
                metrics = results.get("metrics", {})
                
                # Format metrics table
                metrics_table = []
                # Convert metrics to string or numeric values to avoid [object Object] display issues
                for k, v in metrics.items():
                    try:
                        # Check if the value is a dictionary or other complex object
                        if isinstance(v, dict):
                            # For dictionaries, convert to a formatted string representation
                            formatted_value = json.dumps(v, default=str)
                        # Format percentages nicely
                        elif "return" in k.lower() or "drawdown" in k.lower() or "volatility" in k.lower() or "win_rate" in k.lower():
                            formatted_value = f"{float(v) * 100:.2f}%"
                        # Format ratios with fewer decimals
                        elif "ratio" in k.lower() or "factor" in k.lower():
                            formatted_value = f"{float(v):.3f}"
                        # Format other numeric values
                        elif isinstance(v, (int, float)):
                            formatted_value = f"{v:,.3f}"
                        else:
                            # Convert any other objects to string
                            formatted_value = str(v)
                    except (TypeError, ValueError) as e:
                        # Handle conversion errors by showing the raw string and the error
                        formatted_value = f"[Error formatting value: {str(e)}] {str(v)}"
                    
                    metrics_table.append({"Metric": k, "Value": formatted_value})
                
                # Add data sources to metrics table
                for symbol, source in data_sources.items():
                    metrics_table.append({"Metric": f"Data Source ({symbol})", "Value": source.upper()})
                
                # Create plot
                plot = plot_portfolio_results(results)
                
                # Add insights if available
                insights = results.get("insights", "")
                
                # Return in order: metrics table, plot, results JSON, insights
                return metrics_table, plot, json.dumps(results, indent=2), insights
            except json.JSONDecodeError as je:
                logger.error(f"JSON decode error: {je}, Response content: {response.text}")
                return [], None, f"Error decoding response: {response.text}", {}
        else:
            error_msg = f"Error: {response.status_code}"
            try:
                error_detail = response.json().get("detail", "")
                error_msg += f" - {error_detail}"
            except:
                error_msg += f" - {response.text}"
            
            logger.error(error_msg)
            return [], None, error_msg, {}, ""
    except Exception as e:
        logger.error(f"Error running portfolio backtest: {e}")
        return [], None, f"Error: {str(e)}", {}, ""

def plot_portfolio_results(results):
    """Create a plotly figure from portfolio backtest results"""
    try:
        # Extract equity curve
        equity_curve = results.get("equity_curve", [])
        
        if not equity_curve:
            fig = go.Figure()
            fig.update_layout(title="No equity curve data available")
            return fig
        
        # Convert to DataFrame
        dates = [item[0] for item in equity_curve]
        values = [item[1] for item in equity_curve]
        
        # Create figure
        fig = go.Figure()
        
        # Add equity curve
        fig.add_trace(
            go.Scatter(
                x=dates,
                y=values,
                mode="lines",
                name="Portfolio Value",
                line=dict(color="blue", width=2)
            )
        )
        
        # Update layout
        fig.update_layout(
            height=600,
            title_text="Backtest Results",
            showlegend=True,
            legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
            xaxis_title="Date",
            yaxis_title="Portfolio Value ($)"
        )
        
        return fig
    
    except Exception as e:
        # Log the error and provide a fallback
        logger.error(f"Error plotting backtest results: {str(e)}")
        # Create a super simple error figure
        fig = go.Figure()
        fig.add_annotation(
            text="Unable to display backtest results. Please check logs.", 
            showarrow=False,
            font=dict(size=16)
        )
        return fig

# Global variable to store screened symbols
screened_symbols_for_backtest = ""

# Import the screener functions
from ui.screener_functions import (
    run_stock_screener, add_stocks_to_backtest, prepare_for_backtest,
    transfer_to_backtest_tab, load_screened_symbols, deploy_to_alpaca,
    screened_symbols_for_backtest
)

def create_ui():
    """Create the Gradio UI"""
    with gr.Blocks(title="AI Trading Platform", theme=gr.themes.Default()) as demo:
        # Create tabs for different functionality
        with gr.Tabs():
            # Portfolio Tab
            with gr.Tab("Portfolio"):
                with gr.Row():
                    with gr.Column(scale=1):
                        gr.Markdown("### Portfolio Summary")
                        portfolio_json = gr.JSON(label="Portfolio Data")
                    with gr.Column(scale=1):
                        gr.Markdown("### Positions")
                        positions_table = gr.DataFrame(label="Current Positions")
                        
                with gr.Row():
                    refresh_portfolio_btn = gr.Button("Refresh Portfolio")
                    
                # Wire up refresh button
                refresh_portfolio_btn.click(
                    fn=update_portfolio,
                    inputs=[],
                    outputs=[portfolio_json, positions_table]
                )
            
            # Backtest Tab
            with gr.Tab("Backtest"):
                # Agent selection dropdown
                backtest_agent = gr.Dropdown(
                    label="Agent Type",
                    choices=["stocks_agent", "options_agent", "crypto_agent", "customizable_agent"],
                    value="customizable_agent"
                )
                
                # Container for customizable agent settings
                customizable_settings = gr.Group(visible=True)
                
                # Main layout with two columns
                with gr.Row():
                    with gr.Column():
                        # Strategy toggles
                        gr.Markdown("### Strategy Selection")
                        momentum_enabled = gr.Checkbox(label="Momentum Strategy", value=True,
                                                      info="Uses RSI, MACD and price momentum to identify trending markets")
                        mean_reversion_enabled = gr.Checkbox(label="Mean Reversion Strategy", value=True,
                                                         info="Uses Bollinger Bands to buy oversold and sell overbought conditions")
                        breakout_enabled = gr.Checkbox(label="Breakout Strategy", value=True,
                                                    info="Detects price breakouts from ranges with volume confirmation")
                        volatility_enabled = gr.Checkbox(label="Volatility Strategy", value=True,
                                                     info="Uses ATR (Average True Range) to identify high volatility opportunities")
                    
                    with gr.Accordion("Strategy Parameters", open=True):
                        # Technical indicator parameters
                        gr.Markdown("#### Technical Indicators")
                        # RSI parameters
                        rsi_period = gr.Slider(minimum=5, maximum=30, value=14, step=1, label="RSI Period")
                        rsi_overbought = gr.Slider(minimum=60, maximum=90, value=70, step=1, label="RSI Overbought Level")
                        rsi_oversold = gr.Slider(minimum=10, maximum=40, value=30, step=1, label="RSI Oversold Level")
                        
                        # Moving Average parameters
                        ma_fast_period = gr.Slider(minimum=5, maximum=50, value=12, step=1, label="Fast MA Period")
                        ma_slow_period = gr.Slider(minimum=20, maximum=200, value=26, step=1, label="Slow MA Period")
                        
                        # Bollinger Band parameters
                        bb_period = gr.Slider(minimum=10, maximum=50, value=20, step=1, label="Bollinger Band Period")
                        bb_std = gr.Slider(minimum=1.0, maximum=3.0, value=2.0, step=0.1, label="Bollinger Band Standard Deviation")
                    
                    with gr.Accordion("Strategy Weights", open=True):
                        # Strategy weights
                        gr.Markdown("#### Strategy Weights")
                        momentum_weight = gr.Slider(minimum=0, maximum=2, value=1.0, step=0.1, label="Momentum Weight")
                        mean_reversion_weight = gr.Slider(minimum=0, maximum=2, value=1.0, step=0.1, label="Mean Reversion Weight")
                        breakout_weight = gr.Slider(minimum=0, maximum=2, value=1.0, step=0.1, label="Breakout Weight")
                        volatility_weight = gr.Slider(minimum=0, maximum=2, value=0.8, step=0.1, label="Volatility Weight")
                    
                    with gr.Accordion("Risk Management", open=True):
                        # Risk parameters
                        gr.Markdown("#### Risk Parameters")
                        max_position_size = gr.Slider(minimum=0.01, maximum=1.0, value=0.2, step=0.01, 
                                                      label="Max Position Size", info="Maximum % of portfolio in one position")
                        stop_loss = gr.Slider(minimum=0.01, maximum=0.2, value=0.05, step=0.01, 
                                              label="Stop Loss (%)", info="Exit position if losses exceed this percentage")
                        take_profit = gr.Slider(minimum=0.01, maximum=0.4, value=0.1, step=0.01, 
                                               label="Take Profit (%)", info="Exit position when gains reach this percentage")
                        trailing_stop = gr.Checkbox(label="Use Trailing Stop", value=True, 
                                                 info="Adjusts stop loss as price moves in favorable direction")
                
                # Core backtest parameters
                with gr.Row():
                    with gr.Column():
                        with gr.Row():
                            backtest_symbols = gr.Textbox(label="Symbols (comma-separated)", value="AAPL,MSFT,GOOG", info="e.g. AAPL,MSFT,GOOG", scale=4)
                            load_screened_btn = gr.Button("Load from Screener", scale=1)
                        backtest_start = gr.Textbox(label="Start Date", value="2022-01-01", info="YYYY-MM-DD")
                        backtest_end = gr.Textbox(label="End Date", value="2022-12-31", info="YYYY-MM-DD")
                        backtest_capital = gr.Number(label="Initial Capital", value=100000, info="Starting cash amount")
                
                # Data source options
                with gr.Row():
                    use_mock_data = gr.Checkbox(label="Use Mock Data if API Fails", value=True)
                    allow_short_backtest = gr.Checkbox(label="Allow Short Positions", value=False)
                    mock_data_warning = gr.Markdown(visible=False, value="⚠️ **WARNING: Using mock data for backtesting. Results may not reflect actual market behavior.**")                      
                    with gr.Column():
                        # Strategy saving options
                        gr.Markdown("### Save Strategy")
                        strategy_name = gr.Textbox(label="Strategy Name", placeholder="My Custom Strategy")
                        strategy_description = gr.Textbox(label="Strategy Description", placeholder="Description of your strategy", lines=3)
                        save_strategy = gr.Checkbox(label="Save Strategy for Later Use", value=False)
                
                # Function to load screened symbols into backtest tab
                def load_screened_symbols():
                    global screened_symbols_for_backtest
                    if not screened_symbols_for_backtest:
                        return gr.update(value="No screened symbols available. Run the screener first."), ""  
                    return gr.update(value="Loaded symbols from screener"), screened_symbols_for_backtest
                
                # Wire up the load screened symbols button
                load_screened_btn.click(
                    fn=load_screened_symbols,
                    inputs=[],
                    outputs=[gr.Textbox(label="Load Status"), backtest_symbols]
                )
                
                # Run button at the bottom of the Backtest tab
                with gr.Row():
                    run_backtest_btn = gr.Button("Run Backtest", variant="primary", size="large")
                
                # Results section with tabs for different views
                backtest_tabs = gr.Tabs()
                with backtest_tabs:
                    with gr.Tab("Results"):
                        # Performance metrics section
                        with gr.Row():
                            gr.Markdown("## Backtest Performance")
                        
                        with gr.Row():
                            with gr.Column(scale=1):
                                backtest_metrics = gr.DataFrame(
                                    headers=["Metric", "Value"],
                                    label="Performance Metrics"
                                )
                            with gr.Column(scale=1):
                                # Add agent criteria display component
                                agent_criteria_md = gr.Markdown(label="Agent Configuration", value="")
                        
                        # Equity curve section
                        with gr.Row():
                            gr.Markdown("## Equity Curve")
                        
                        with gr.Row():
                            backtest_plot = gr.Plot(label="Portfolio Performance")
                        
                        # Trades section
                        with gr.Row():
                            gr.Markdown("## Trades")
                            
                        with gr.Row():
                            trades_table = gr.DataFrame(
                                headers=["Date", "Symbol", "Action", "Price", "Quantity", "Value"],
                                label="Trade History"
                            )
                        
                        # Hidden JSON results for debugging
                        with gr.Row(visible=False):
                            backtest_results = gr.JSON(label="Backtest Results")
            
            # Add JavaScript to show/hide customizable agent settings
            backtest_agent.change(
                fn=lambda agent: {"visible": agent == "customizable_agent"},
                inputs=[backtest_agent],
                outputs=[customizable_settings]
            )
            
            # Function to prepare customizable agent config
            def prepare_customizable_config(agent_type, momentum_enabled, mean_reversion_enabled, 
                                          breakout_enabled, volatility_enabled, 
                                          rsi_period, rsi_overbought, rsi_oversold,
                                          ma_fast_period, ma_slow_period, bb_period, bb_std,
                                          momentum_weight, mean_reversion_weight, breakout_weight, volatility_weight,
                                          max_position_size, stop_loss, take_profit, trailing_stop):
                # Only prepare config if using customizable agent
                if agent_type != "customizable_agent":
                    return agent_type
                
                # Create JSON config as a string
                config = {
                    "strategies": {
                        "momentum": {
                            "enabled": momentum_enabled, 
                            "weight": momentum_weight,
                            "params": {
                                "rsi_period": rsi_period,
                                "rsi_overbought": rsi_overbought,
                                "rsi_oversold": rsi_oversold,
                                "macd_fast": ma_fast_period,
                                "macd_slow": ma_slow_period,
                                "macd_signal": 9
                            }
                        },
                        "mean_reversion": {
                            "enabled": mean_reversion_enabled, 
                            "weight": mean_reversion_weight,
                            "params": {
                                "bollinger_period": bb_period,
                                "bollinger_std": bb_std,
                                "vwap_period": 14
                            }
                        },
                        "breakout": {
                            "enabled": breakout_enabled, 
                            "weight": breakout_weight,
                            "params": {
                                "atr_period": 14,
                                "atr_multiplier": 2.0,
                                "ma_periods": [20, 50, 200]
                            }
                        },
                        "volatility": {
                            "enabled": volatility_enabled, 
                            "weight": volatility_weight,
                            "params": {
                                "atr_period": 14,
                                "atr_multiplier": 1.5
                            }
                        }
                    },
                    "position_sizing": {
                        "max_position_size": max_position_size,
                        "signal_threshold": 0.5,
                        "scale_by_strength": True
                    },
                    "risk_management": {
                        "stop_loss": stop_loss,
                        "take_profit": take_profit,
                        "trailing_stop": trailing_stop
                    }
                }
                
                # Convert to JSON string to pass to backend
                import json
                return f"customizable_agent:{json.dumps(config)}"
            
            # Let's simplify the approach and move the function into the main run_backtest
            # Define a modified version of run_backtest that processes the agent settings
            def process_and_run_backtest(agent_type, 
                                       # Strategy toggles
                                       momentum_enabled, mean_reversion_enabled, breakout_enabled, volatility_enabled,
                                       # Technical indicator parameters
                                       rsi_period, rsi_overbought, rsi_oversold,
                                       ma_fast_period, ma_slow_period, bb_period, bb_std,
                                       # Strategy weights
                                       momentum_weight, mean_reversion_weight, breakout_weight, volatility_weight,
                                       # Risk parameters
                                       max_position_size, stop_loss, take_profit, trailing_stop,
                                       # Core backtest parameters
                                       backtest_symbols, backtest_start, backtest_end, backtest_capital,
                                       # Data source options
                                       use_mock_data,
                                       # Strategy saving parameters
                                       strategy_name, strategy_description, save_strategy):
    
                try:
                    # Import the new BacktraderEngine
                    from backtest.backtrader_engine import BacktraderEngine
                    from data.data_fetcher import DataFetcher
                    import pandas as pd
                    import plotly.graph_objects as go
                    import json
                    import logging
                    
                    logger = logging.getLogger(__name__)
                    
                    # Initialize data fetcher and backtest engine
                    data_fetcher = DataFetcher()
                    engine = BacktraderEngine(data_fetcher=data_fetcher, use_mock_data=use_mock_data)
                    
                    # Process symbols and check for position types
                    symbol_list = []
                    position_types = {}
                    
                    for s in backtest_symbols.split(","):
                        s = s.strip()
                        if not s:
                            continue
                            
                        # Check if symbol has position type indicator
                        if ":short" in s:
                            symbol = s.split(":short")[0].strip()
                            position_types[symbol] = "short"
                            symbol_list.append(symbol)
                        else:
                            symbol_list.append(s)
                            position_types[s] = "long"  # Default to long
                    
                    logger.info(f"Processed symbols: {symbol_list} with position types: {position_types}")
                    
                    # Process strategy parameters
                    if agent_type == "customizable_agent":
                        # Map UI parameters to BacktraderEngine parameters
                        strategy_params = {
                            'rsi_period': int(rsi_period),
                            'rsi_overbought': int(rsi_overbought),
                            'rsi_oversold': int(rsi_oversold),
                            'sma_period_fast': int(ma_fast_period),
                            'sma_period_slow': int(ma_slow_period),
                            'stop_loss': float(stop_loss) / 100,  # Convert from percentage to decimal
                            'take_profit': float(take_profit) / 100,  # Convert from percentage to decimal
                            'risk_pct': float(max_position_size) / 100,  # Convert from percentage to decimal
                            'trailing_stop': trailing_stop,
                            'momentum_weight': float(momentum_weight if momentum_enabled else 0),
                            'mean_reversion_weight': float(mean_reversion_weight if mean_reversion_enabled else 0),
                            'breakout_weight': float(breakout_weight if breakout_enabled else 0),
                            'volatility_weight': float(volatility_weight if volatility_enabled else 0),
                            'debug': True  # Enable debug logging for development
                        }
                        
                        # Add strategy
                        engine.add_strategy(strategy_type='ShrekStrategy', **strategy_params)
                    else:
                        # For predefined agents, we just pass the agent type
                        engine.add_strategy(strategy_type=agent_type)
                    
                    # Add data
                    success, data_source = engine.add_data(symbol_list, backtest_start, backtest_end, position_types=position_types)
                    
                    if not success:
                        # Return error if data loading failed
                        return [], None, f"Failed to load data: {data_source}", {}, {}, gr.update(visible=False)
                    
                    # Run backtest
                    results = engine.run_backtest(initial_cash=float(backtest_capital))
                    
                    if not results.get('success', False):
                        # Return error if backtest failed
                        return [], None, f"Backtest failed: {results.get('error', 'Unknown error')}", {}, {}, gr.update(visible=False)
                    
                    # Format metrics for display
                    metrics_table = []
                    for key, value in results.get('metrics', {}).items():
                        if isinstance(value, (int, float)):
                            if abs(value) > 1:
                                metrics_table.append([key.replace('_', ' ').title(), f"{value:.2f}"])
                            else:
                                metrics_table.append([key.replace('_', ' ').title(), f"{value:.4f}"])
                        else:
                            metrics_table.append([key.replace('_', ' ').title(), str(value)])
                    
                    # Create equity curve plot
                    equity_curve = results.get('equity_curve', [])
                    if equity_curve:
                        dates = [item.get('date') for item in equity_curve]
                        values = [item.get('value') for item in equity_curve]
                        
                        fig = go.Figure()
                        fig.add_trace(go.Scatter(
                            x=dates, 
                            y=values,
                            mode='lines',
                            name='Portfolio Value',
                            line=dict(color='blue', width=2)
                        ))
                        
                        # Add buy/sell markers based on trades
                        trades = results.get('trades', [])
                        if trades:
                            buy_dates = [trade.get('entry_date') for trade in trades]
                            buy_prices = [trade.get('entry_price') for trade in trades]
                            
                            sell_dates = [trade.get('exit_date') for trade in trades]
                            sell_prices = [trade.get('exit_price') for trade in trades]
                            
                            fig.add_trace(go.Scatter(
                                x=buy_dates,
                                y=buy_prices,
                                mode='markers',
                                name='Buy',
                                marker=dict(color='green', size=10, symbol='triangle-up')
                            ))
                            
                            fig.add_trace(go.Scatter(
                                x=sell_dates,
                                y=sell_prices,
                                mode='markers',
                                name='Sell',
                                marker=dict(color='red', size=10, symbol='triangle-down')
                            ))
                        
                        fig.update_layout(
                            title='Equity Curve',
                            xaxis_title='Date',
                            yaxis_title='Portfolio Value ($)',
                            template='plotly_white'
                        )
                        plot = fig
                    else:
                        plot = None
                    
                    # Format agent configuration for display
                    criteria_md = f"## Agent Configuration\n\n"
                    criteria_md += f"**Agent Type:** {agent_type}\n\n"
                    
                    if agent_type == "customizable_agent":
                        criteria_md += "### Enabled Strategies:\n"
                        if momentum_enabled:
                            criteria_md += f"- Momentum (Weight: {momentum_weight})\n"
                        if mean_reversion_enabled:
                            criteria_md += f"- Mean Reversion (Weight: {mean_reversion_weight})\n"
                        if breakout_enabled:
                            criteria_md += f"- Breakout (Weight: {breakout_weight})\n"
                        if volatility_enabled:
                            criteria_md += f"- Volatility (Weight: {volatility_weight})\n"
                        
                        criteria_md += "\n### Technical Parameters:\n"
                        criteria_md += f"- RSI Period: {rsi_period}\n"
                        criteria_md += f"- RSI Overbought: {rsi_overbought}\n"
                        criteria_md += f"- RSI Oversold: {rsi_oversold}\n"
                        criteria_md += f"- MA Fast Period: {ma_fast_period}\n"
                        criteria_md += f"- MA Slow Period: {ma_slow_period}\n"
                        criteria_md += f"- Bollinger Bands Period: {bb_period}\n"
                        criteria_md += f"- Bollinger Bands STD: {bb_std}\n"
                        
                        criteria_md += "\n### Risk Management:\n"
                        criteria_md += f"- Max Position Size: {max_position_size}%\n"
                        criteria_md += f"- Stop Loss: {stop_loss}%\n"
                        criteria_md += f"- Take Profit: {take_profit}%\n"
                        criteria_md += f"- Trailing Stop: {'Enabled' if trailing_stop else 'Disabled'}\n"
                    
                    # Format trades for display
                    trades_data = []
                    for trade in results.get('trades', []):
                        profit_loss = trade.get('profit_loss', 0)
                        profit_loss_color = 'green' if profit_loss > 0 else 'red'
                        
                        trades_data.append({
                            'Date': trade.get('exit_date', ''),
                            'Symbol': trade.get('symbol', 'UNKNOWN'),
                            'Action': 'SELL' if trade.get('type', '') == 'sell' else 'BUY',
                            'Entry Price': f"${trade.get('entry_price', 0):.2f}",
                            'Exit Price': f"${trade.get('exit_price', 0):.2f}",
                            'P&L': f"${profit_loss:.2f}",
                            'P&L %': f"{trade.get('profit_loss_pct', 0):.2f}%"
                        })
                    
                    # Sort trades by date
                    trades_data.sort(key=lambda x: x.get('Date', ''), reverse=True)
                    
                    # Check if using mock data
                    using_mock_data = results.get('data_source') == 'mock'
                    
                    # Save strategy if requested
                    if save_strategy and strategy_name:
                        try:
                            # Format strategy details
                            strategy_info = {
                                "name": strategy_name,
                                "description": strategy_description or "Custom strategy",
                                "agent_type": agent_type,
                                "parameters": strategy_params if agent_type == "customizable_agent" else {},
                                "performance": {
                                    "total_return": results.get('metrics', {}).get('total_return', 0),
                                    "sharpe_ratio": results.get('metrics', {}).get('sharpe_ratio', 0),
                                    "max_drawdown": results.get('metrics', {}).get('max_drawdown', 0),
                                    "win_rate": results.get('metrics', {}).get('win_rate', 0)
                                },
                                "test_period": {
                                    "start_date": backtest_start,
                                    "end_date": backtest_end,
                                    "symbols": symbol_list
                                }
                            }
                            
                            # Save strategy (using API endpoint)
                            response = requests.post(
                                f"{API_BASE_URL}/strategy/",
                                json={"strategy": strategy_info}
                            )
                            
                            if response.status_code != 200:
                                logger.error(f"Failed to save strategy: {response.text}")
                            
                        except Exception as e:
                            logger.error(f"Error saving strategy: {str(e)}")
                    
                    # Return results and update UI components
                    return metrics_table, plot, criteria_md, trades_data, results, gr.update(visible=using_mock_data)
                    
                except Exception as e:
                    import traceback
                    logger.error(f"Error in process_and_run_backtest: {str(e)}\n{traceback.format_exc()}")
                    return [], None, f"Error: {str(e)}", {}, {}, gr.update(visible=False)
            
            # Show/hide customizable settings based on agent selection
            backtest_agent.change(fn=lambda x: gr.update(visible=(x == "customizable_agent")), 
                                inputs=[backtest_agent], outputs=customizable_settings)
            
            # Define a function to handle the backtest results and show the results tab
            def handle_backtest_results(*args):
                # Call the process_and_run_backtest function with all the arguments
                results = process_and_run_backtest(*args)
                # The results are already returned to the UI components
                # We don't need to explicitly select the tab as it will be visible
                # when the results are displayed
                return results
            
            # Set up backtest button with all parameters
            run_backtest_btn.click(
                fn=handle_backtest_results,
                inputs=[
                    # Agent selection
                    backtest_agent, 
                    # Strategy toggles
                    momentum_enabled, mean_reversion_enabled, breakout_enabled, volatility_enabled,
                    # Technical indicator parameters
                    rsi_period, rsi_overbought, rsi_oversold,
                    ma_fast_period, ma_slow_period, bb_period, bb_std,
                    # Strategy weights
                    momentum_weight, mean_reversion_weight, breakout_weight, volatility_weight,
                    # Risk parameters
                    max_position_size, stop_loss, take_profit, trailing_stop,
                    # Core backtest parameters
                    backtest_symbols, backtest_start, backtest_end, backtest_capital,
                    # Data source options
                    use_mock_data, allow_short_backtest,
                    # Strategy saving parameters
                    strategy_name, strategy_description, save_strategy
                ],
                outputs=[backtest_metrics, backtest_plot, agent_criteria_md, trades_table, backtest_results, mock_data_warning]
            )
            
            # Stock Screener Tab
            with gr.Tab("Stock Screener"):
                with gr.Row():
                    with gr.Column(scale=1):
                        gr.Markdown("### Stock Screening Criteria")
                        
                        # Universe selection
                        universe_input = gr.Textbox(
                            label="Stock Universe", 
                            placeholder="Leave blank for S&P 500 or enter comma-separated symbols",
                            info="Leave blank to screen S&P 500 stocks or enter specific symbols"
                        )
                        
                        # Price criteria
                        with gr.Accordion("Price Criteria", open=True):
                            min_price = gr.Number(label="Minimum Price ($)", value=5)
                            max_price = gr.Number(label="Maximum Price ($)", value=1000)
                            min_volume = gr.Number(label="Minimum Volume", value=100000)
                        
                        # Technical indicators
                        with gr.Accordion("Technical Indicators", open=True):
                            min_volatility = gr.Number(label="Minimum Volatility (%)", value=1)
                            max_volatility = gr.Number(label="Maximum Volatility (%)", value=5)
                            min_rsi = gr.Number(label="Minimum RSI", value=30)
                            max_rsi = gr.Number(label="Maximum RSI", value=70)
                            
                            price_above_sma50 = gr.Checkbox(label="Price Above 50-day SMA", value=False)
                            price_below_sma50 = gr.Checkbox(label="Price Below 50-day SMA", value=False)
                            price_above_sma200 = gr.Checkbox(label="Price Above 200-day SMA", value=False)
                            price_below_sma200 = gr.Checkbox(label="Price Below 200-day SMA", value=False)
                            
                            macd_positive = gr.Checkbox(label="MACD Positive", value=False)
                            macd_negative = gr.Checkbox(label="MACD Negative", value=False)
                        
                        # Sorting options
                        with gr.Accordion("Sorting Options", open=True):
                            sort_by = gr.Dropdown(
                                label="Sort By",
                                choices=["Symbol", "Price", "Volume", "Volatility", "RSI"],
                                value="Volume"
                            )
                            sort_ascending = gr.Checkbox(label="Sort Ascending", value=False)
                            max_results = gr.Number(label="Maximum Results", value=50)
                        
                        # Position type
                        allow_short_positions = gr.Checkbox(label="Allow Short Positions", value=False)
                        
                        # Run button
                        run_screener_btn = gr.Button("Run Stock Screener", variant="primary")
                    
                    with gr.Column(scale=1):
                        # Results
                        screener_results = gr.DataFrame(label="Screener Results")
                        
                        # Add to backtest selection
                        add_to_backtest_btn = gr.Button("Add Selected to Backtest")
                        selected_stocks = gr.DataFrame(label="Selected Stocks for Backtesting")
                        
                        # Transfer to backtest tab
                        transfer_to_backtest_btn = gr.Button("Transfer to Backtest Tab", variant="secondary")
                        transfer_status = gr.Textbox(label="Transfer Status")
                
                # Wire up the screener button
                run_screener_btn.click(
                    fn=run_stock_screener,
                    inputs=[
                        universe_input, min_price, max_price, min_volume,
                        min_volatility, max_volatility, min_rsi, max_rsi,
                        price_above_sma50, price_below_sma50,
                        price_above_sma200, price_below_sma200,
                        macd_positive, macd_negative,
                        sort_by, sort_ascending, max_results
                    ],
                    outputs=[screener_results]
                )
                
                # Wire up the add to backtest button
                add_to_backtest_btn.click(
                    fn=add_stocks_to_backtest,
                    inputs=[screener_results, allow_short_positions],
                    outputs=[selected_stocks]
                )
                
                # Wire up the transfer button
                transfer_to_backtest_btn.click(
                    fn=transfer_to_backtest_tab,
                    inputs=[selected_stocks],
                    outputs=[transfer_status]
                )
            
            # Alpaca Trading Tab
            with gr.Tab("Alpaca Trading"):
                with gr.Row():
                    with gr.Column(scale=1):
                        gr.Markdown("### Alpaca Paper Trading Configuration")
                        
                        # API Keys
                        with gr.Accordion("API Keys", open=True):
                            alpaca_api_key = gr.Textbox(label="Alpaca API Key", type="password")
                            alpaca_api_secret = gr.Textbox(label="Alpaca API Secret", type="password")
                            alpaca_paper = gr.Checkbox(label="Use Paper Trading", value=True)
                        
                        # Strategy Selection
                        with gr.Accordion("Strategy Selection", open=True):
                            # Dropdown for saved strategies
                            strategy_dropdown = gr.Dropdown(
                                label="Select Strategy", 
                                choices=["Custom Strategy", "Mean Reversion", "Momentum", "Breakout"],
                                value="Custom Strategy"
                            )
                            min_volume = gr.Number(label="Minimum Volume", value=100000)
                        
                        # Technical indicators
                        with gr.Accordion("Technical Indicators", open=True):
                            min_volatility = gr.Number(label="Minimum Volatility (%)", value=1)
                            max_volatility = gr.Number(label="Maximum Volatility (%)", value=5)
                            min_rsi = gr.Number(label="Minimum RSI", value=30)
                            max_rsi = gr.Number(label="Maximum RSI", value=70)
                            
                            price_above_sma50 = gr.Checkbox(label="Price Above 50-day SMA", value=False)
                            price_below_sma50 = gr.Checkbox(label="Price Below 50-day SMA", value=False)
                            price_above_sma200 = gr.Checkbox(label="Price Above 200-day SMA", value=False)
                            price_below_sma200 = gr.Checkbox(label="Price Below 200-day SMA", value=False)
                            
                            macd_positive = gr.Checkbox(label="MACD Positive", value=False)
                            macd_negative = gr.Checkbox(label="MACD Negative", value=False)
                        
                        # Sorting options
                        with gr.Accordion("Sorting Options", open=True):
                            sort_by = gr.Dropdown(
                                label="Sort By",
                                choices=["Symbol", "Price", "Volume", "Volatility", "RSI"],
                                value="Volume"
                            )
                            sort_ascending = gr.Checkbox(label="Sort Ascending", value=False)
                            max_results = gr.Number(label="Maximum Results", value=50)
                        
                        # Position type
                        allow_short_positions = gr.Checkbox(label="Allow Short Positions", value=False)
                        
                        # Run button
                        run_screener_btn = gr.Button("Run Stock Screener", variant="primary")
                    
                    with gr.Column(scale=1):
                        # Results
                        screener_results = gr.DataFrame(label="Screener Results")
                        
                        # Add to backtest selection
                        add_to_backtest_btn = gr.Button("Add Selected to Backtest")
                        selected_stocks = gr.DataFrame(label="Selected Stocks for Backtesting")
                        
                        # Transfer to backtest tab
                        transfer_to_backtest_btn = gr.Button("Transfer to Backtest Tab", variant="secondary")
                        transfer_status = gr.Textbox(label="Transfer Status")
                
                # Wire up the screener button
                run_screener_btn.click(
                    fn=run_stock_screener,
                    inputs=[
                        universe_input, min_price, max_price, min_volume,
                        min_volatility, max_volatility, min_rsi, max_rsi,
                        price_above_sma50, price_below_sma50,
                        price_above_sma200, price_below_sma200,
                        macd_positive, macd_negative,
                        sort_by, sort_ascending, max_results
                    ],
                    outputs=[screener_results]
                )
                
                # Wire up the add to backtest button
                add_to_backtest_btn.click(
                    fn=add_stocks_to_backtest,
                    inputs=[screener_results, allow_short_positions],
                    outputs=[selected_stocks]
                )
                
                # Wire up the transfer button
                transfer_to_backtest_btn.click(
                    fn=transfer_to_backtest_tab,
                    inputs=[selected_stocks],
                    outputs=[transfer_status]
                )
            
            # Saved Strategies Tab
                    
                    # Price criteria
                    with gr.Row():
                        min_price = gr.Number(label="Min Price ($)", value=10)
                        max_price = gr.Number(label="Max Price ($)", value=1000)
                    
                    # Volume criteria
                    min_volume = gr.Number(label="Min Daily Volume", value=100000)
                    
                    # Volatility criteria
                    with gr.Row():
                        min_volatility = gr.Number(label="Min Volatility (%)", value=0)
                        max_volatility = gr.Number(label="Max Volatility (%)", value=100)
                    
                    # RSI criteria
                    with gr.Row():
                        min_rsi = gr.Number(label="Min RSI", value=0, minimum=0, maximum=100)
                        max_rsi = gr.Number(label="Max RSI", value=100, minimum=0, maximum=100)
                    
                    # Moving average criteria
                    price_above_sma50 = gr.Checkbox(label="Price Above 50-day MA", value=False)
                    price_below_sma50 = gr.Checkbox(label="Price Below 50-day MA", value=False)
                    price_above_sma200 = gr.Checkbox(label="Price Above 200-day MA", value=False)
                    price_below_sma200 = gr.Checkbox(label="Price Below 200-day MA", value=False)
                    
                    # MACD criteria
                    macd_positive = gr.Checkbox(label="MACD Positive", value=False)
                    macd_negative = gr.Checkbox(label="MACD Negative", value=False)
                    
                    # Sorting and limits
                    with gr.Row():
                        sort_by = gr.Dropdown(
                            label="Sort By", 
                            choices=["Symbol", "Price", "Volume", "Volatility", "RSI", "Daily_Change_%"], 
                            value="Volume"
                        )
                        sort_ascending = gr.Checkbox(label="Sort Ascending", value=False)
                    
                    max_results = gr.Slider(minimum=5, maximum=100, value=20, step=5, label="Max Results")
                    
                    # Allow short positions
                    allow_short_positions = gr.Checkbox(label="Allow Short Positions", value=False)
                    
                    # Run button
                    run_screener_btn = gr.Button("Run Stock Screener", variant="primary")
                
                with gr.Column(scale=1):
                    # Results section
                    gr.Markdown("### Screening Results")
                    screener_results = gr.Dataframe(
                        headers=["Symbol", "Price", "Volume", "Volatility_20d", "RSI_14", "Daily_Change_%", "Above_50MA", "Above_200MA", "MACD"],
                        label="Screener Results",
                        interactive=False,
                        wrap=True
                    )
                    
                    # Add to backtest button
                    add_to_backtest_btn = gr.Button("Add Selected to Backtest", variant="secondary")
            
            # Selected stocks section
            with gr.Row():
                with gr.Column(scale=1):
                    gr.Markdown("### Selected Stocks for Backtesting")
                    selected_stocks = gr.Dataframe(
                        headers=["Symbol", "Price", "Position Type"],
                        label="Selected Stocks",
                        interactive=True,
                        row_count=5,
                        col_count=(3, "fixed")
                    )
                with gr.Column(scale=1):
                    transfer_to_backtest_btn = gr.Button("Transfer to Backtest Tab", variant="secondary")
                    backtest_symbols_output = gr.Textbox(label="Symbols for Backtest", visible=False)
            
            # Function to run the stock screener
            def run_stock_screener(universe, min_price, max_price, min_volume, min_volatility, max_volatility,
                                 min_rsi, max_rsi, price_above_sma50, price_below_sma50,
                                 price_above_sma200, price_below_sma200, macd_positive, macd_negative,
                                 sort_by, sort_ascending, max_results):
                try:
                    # Import the stock screener
                    from screener.stock_screener import StockScreener
                    import pandas as pd
                    import logging
                    
                    logger = logging.getLogger(__name__)
                    
                    # Parse universe if provided
                    universe_list = None
                    if universe and universe.strip():
                        universe_list = [s.strip() for s in universe.split(',')]
                    
                    # Create screener instance
                    screener = StockScreener()
                    
                    # Apply filters
                    results = screener.screen_stocks(
                        universe=universe_list,
                        min_price=min_price,
                        max_price=max_price,
                        min_volume=min_volume,
                        min_volatility=min_volatility/100,  # Convert to decimal
                        max_volatility=max_volatility/100,  # Convert to decimal
                        min_rsi=min_rsi,
                        max_rsi=max_rsi,
                        price_above_sma50=price_above_sma50,
                        price_below_sma50=price_below_sma50,
                        price_above_sma200=price_above_sma200,
                        price_below_sma200=price_below_sma200,
                        macd_positive=macd_positive,
                        macd_negative=macd_negative,
                        sort_by=sort_by,
                        ascending=sort_ascending,
                        limit=max_results
                    )
                    
                    if results.empty:
                        logger.warning("No stocks matched the screening criteria")
                        return pd.DataFrame()
                    
                    # Format results for display
                    # Round numeric columns
                    for col in results.select_dtypes(include=['float']).columns:
                        if col in ['Daily_Change_%', 'Volatility_20d']:
                            results[col] = results[col].round(2)
                        else:
                            results[col] = results[col].round(4)
                    
                    return results
                    
                except Exception as e:
                    logger.error(f"Error running stock screener: {str(e)}")
                    import traceback
                    logger.error(traceback.format_exc())
                    return pd.DataFrame()
            
            # Function to add selected stocks to backtest
            def add_stocks_to_backtest(results, allow_short):
                try:
                    import pandas as pd
                    
                    # Get selected rows (all rows for now)
                    selected = results.copy()
                    
                    if selected.empty:
                        return pd.DataFrame(columns=["Symbol", "Price", "Position Type"])
                    
                    # Create dataframe for selected stocks
                    selected_data = []
                    for _, row in selected.iterrows():
                        position_type = "Short" if allow_short else "Long"
                        selected_data.append({
                            "Symbol": row["Symbol"],
                            "Price": row["Price"],
                            "Position Type": position_type
                        })
                    
                    return pd.DataFrame(selected_data)
                    
                except Exception as e:
                    logger.error(f"Error adding stocks to backtest: {str(e)}")
                    return pd.DataFrame(columns=["Symbol", "Price", "Position Type"])
            
            # Wire up the screener button
            run_screener_btn.click(
                fn=run_stock_screener,
                inputs=[
                    universe_input, min_price, max_price, min_volume, min_volatility, max_volatility,
                    min_rsi, max_rsi, price_above_sma50, price_below_sma50,
                    price_above_sma200, price_below_sma200, macd_positive, macd_negative,
                    sort_by, sort_ascending, max_results
                ],
                outputs=[screener_results]
            )
            
            # Function to prepare stocks for backtest tab
            def prepare_for_backtest(selected_stocks_df):
                try:
                    if selected_stocks_df.empty:
                        return ""
                    
                    # Extract symbols and position types
                    symbols = []
                    for _, row in selected_stocks_df.iterrows():
                        symbol = row["Symbol"]
                        position_type = row["Position Type"]
                        # Add position type indicator to symbol
                        if position_type == "Short":
                            symbol = f"{symbol}:short"
                        symbols.append(symbol)
                    
                    # Join with commas
                    return ",".join(symbols)
                except Exception as e:
                    logger.error(f"Error preparing stocks for backtest: {str(e)}")
                    return ""
            
            # Function to transfer symbols to backtest tab
            def transfer_to_backtest_tab(selected_stocks_df):
                symbols_str = prepare_for_backtest(selected_stocks_df)
                if not symbols_str:
                    return gr.update(value="No stocks selected")
                    
                # Store the symbols string for later use
                global screened_symbols_for_backtest
                screened_symbols_for_backtest = symbols_str
                
                # Return a success message
                return gr.update(value=f"Transferred {len(symbols_str.split(','))} stocks to backtest tab. Switch to Backtest tab to use them.")
            
            # Wire up the buttons
            add_to_backtest_btn.click(
                fn=add_stocks_to_backtest,
                inputs=[screener_results, allow_short_positions],
                outputs=[selected_stocks]
            )
            
            transfer_to_backtest_btn.click(
                fn=transfer_to_backtest_tab,
                inputs=[selected_stocks],
                outputs=[gr.Textbox(label="Transfer Status")]
            )
            
        # Saved Strategies Tab
            with gr.Tab("Saved Strategies"):
                with gr.Row():
                    with gr.Column(scale=1):
                        gr.Markdown("### Saved Trading Strategies")
                        refresh_strategies_btn = gr.Button("Refresh Strategies List")
                        strategies_table = gr.DataFrame(
                        headers=["ID", "Name", "Agent Type", "Symbols", "Created", "Total Return", "Sharpe", "Win Rate"],
                        label="Saved Strategies"
                    )
            
            with gr.Row():
                with gr.Column(scale=1):
                    selected_strategy_id = gr.Textbox(label="Selected Strategy ID", placeholder="Enter strategy ID to view or deploy")
                    view_strategy_btn = gr.Button("View Strategy Details")
                    deploy_strategy_btn = gr.Button("Deploy for Live Trading")
                    broker_dropdown = gr.Dropdown(
                        ["paper", "alpaca", "robinhood"],
                        label="Trading Broker",
                        value="paper"
                    )
                
            with gr.Row():
                strategy_details = gr.JSON(label="Strategy Details")
                deployment_result = gr.JSON(label="Deployment Result")
            
            # Strategy list refresh function
            def fetch_strategies_list():
                try:
                    response = requests.get(f"{API_BASE_URL}/strategies")
                    if response.status_code == 200:
                        strategies = response.json().get("strategies", [])
                        # Format for display in table
                        table_data = []
                        for s in strategies:
                            performance = s.get("performance", {})
                            total_return = performance.get("total_return", 0)
                            sharpe = performance.get("sharpe_ratio", 0)
                            win_rate = performance.get("win_rate", 0)
                            
                            # Format as percentages where appropriate
                            if isinstance(total_return, (int, float)):
                                total_return = f"{total_return*100:.2f}%"
                            if isinstance(win_rate, (int, float)):
                                win_rate = f"{win_rate*100:.2f}%"
                            
                            table_data.append([
                                s.get("id", ""),
                                s.get("name", ""),
                                s.get("agent_type", ""),
                                ", ".join(s.get("symbols", [])),
                                s.get("created_at", "").split("T")[0] if s.get("created_at") else "",
                                total_return,
                                f"{sharpe:.2f}" if isinstance(sharpe, (int, float)) else sharpe,
                                win_rate
                            ])
                        return table_data
                    else:
                        return [[f"Error: {response.status_code}", "", "", "", "", "", "", ""]]
                except Exception as e:
                    logger.error(f"Error fetching strategies list: {e}")
                    return [[f"Error: {str(e)}", "", "", "", "", "", "", ""]]
            
            # View strategy details function
            def view_strategy(strategy_id):
                if not strategy_id:
                    return {"error": "Please enter a strategy ID"}
                try:
                    response = requests.get(f"{API_BASE_URL}/strategies/{strategy_id}")
                    if response.status_code == 200:
                        return response.json()
                    else:
                        return {"error": f"Error: {response.status_code}"}
                except Exception as e:
                    logger.error(f"Error viewing strategy: {e}")
                    return {"error": f"Error: {str(e)}"}
            
            # Deploy strategy function
            def deploy_strategy(strategy_id, broker):
                if not strategy_id:
                    return {"error": "Please enter a strategy ID"}
                try:
                    payload = {"strategy_id": strategy_id, "broker": broker}
                    response = requests.post(f"{API_BASE_URL}/strategies/deploy", json=payload)
                    if response.status_code == 200:
                        return response.json()
                    else:
                        return {"error": f"Error: {response.status_code}"}
                except Exception as e:
                    logger.error(f"Error deploying strategy: {e}")
                    return {"error": f"Error: {str(e)}"}
            
            # Wire up the buttons
            refresh_strategies_btn.click(
                fn=fetch_strategies_list,
                inputs=[],
                outputs=[strategies_table]
            )
            
            view_strategy_btn.click(
                fn=view_strategy,
                inputs=[selected_strategy_id],
                outputs=[strategy_details]
            )
            
            deploy_strategy_btn.click(
                fn=deploy_strategy,
                inputs=[selected_strategy_id, broker_dropdown],
                outputs=[deployment_result]
            )
            
            # Load strategies on startup
            demo.load(
                fn=fetch_strategies_list,
                inputs=[],
                outputs=[strategies_table]
            )
        
        # Portfolio Backtest Tab
            with gr.Tab("Portfolio Backtest"):
                
                with gr.Row():
                    with gr.Column(scale=1):
                        gr.Markdown("### Portfolio Configuration")
                        portfolio_allocations = gr.Textbox(
                        label="Asset Allocations (symbol: weight)", 
                        value="AAPL: 0.4\nMSFT: 0.3\nGOOG: 0.3",
                        lines=10
                    )
                    portfolio_strategies = gr.Textbox(
                        label="Symbol Strategies (symbol: strategy_name)", 
                        value="AAPL: customizable\nMSFT: momentum\nGOOG: mean_reversion",
                        lines=10
                    )
                    portfolio_start = gr.Textbox(label="Start Date (YYYY-MM-DD)", value="2023-01-01")
                    portfolio_end = gr.Textbox(label="End Date (YYYY-MM-DD)", value="2023-12-31")
                    generate_insights = gr.Checkbox(label="Generate LLM Insights", value=False)
                    run_portfolio_btn = gr.Button("Run Portfolio Backtest")
            
            with gr.Row():
                portfolio_metrics = gr.DataFrame(
                    headers=["Metric", "Value"],
                    label="Portfolio Performance Metrics"
                )
            
            with gr.Row():
                portfolio_plot = gr.Plot(label="Portfolio Equity Curve")
            
            with gr.Row():
                with gr.Column(scale=1):
                    portfolio_results = gr.JSON(label="Portfolio Results")
                with gr.Column(scale=1):
                    portfolio_insights = gr.Textbox(label="LLM Insights", lines=20)
            
            # Set up portfolio backtest button
            run_portfolio_btn.click(
                run_portfolio_backtest,
                inputs=[
                    portfolio_allocations, 
                    portfolio_strategies, 
                    portfolio_start, 
                    portfolio_end, 
                    generate_insights
                ],
                outputs=[
                    portfolio_metrics, 
                    portfolio_plot, 
                    portfolio_results,
                    portfolio_insights
                ]
            )
            
            # Initialize with default data
            try:
                demo.load(
                    fn=lambda: update_portfolio(),
                    outputs=[portfolio_json, positions_table]
                )
            except Exception as e:
                logger.error(f"Error loading initial data: {e}")
            
        # Alpaca Trading Tab
            with gr.Tab("Alpaca Trading"):
                with gr.Row():
                    with gr.Column(scale=1):
                        gr.Markdown("### Alpaca Paper Trading Configuration")
                    
                    # API Keys
                    with gr.Accordion("API Keys", open=True):
                        alpaca_api_key = gr.Textbox(label="Alpaca API Key", type="password")
                        alpaca_api_secret = gr.Textbox(label="Alpaca API Secret", type="password")
                        alpaca_paper = gr.Checkbox(label="Use Paper Trading", value=True)
                    
                    # Strategy Selection
                    with gr.Accordion("Strategy Selection", open=True):
                        # Dropdown for saved strategies
                        strategy_dropdown = gr.Dropdown(
                            label="Select Strategy", 
                            choices=["Custom Strategy", "Mean Reversion", "Momentum", "Breakout"],
                            value="Custom Strategy"
                        )
                        
                        # Custom strategy parameters
                        with gr.Group(visible=True) as custom_strategy_params:
                            gr.Markdown("### Custom Strategy Parameters")
                            # Strategy toggles
                            momentum_enabled = gr.Checkbox(label="Enable Momentum", value=True)
                            mean_reversion_enabled = gr.Checkbox(label="Enable Mean Reversion", value=True)
                            breakout_enabled = gr.Checkbox(label="Enable Breakout", value=True)
                            volatility_enabled = gr.Checkbox(label="Enable Volatility", value=True)
                            
                            # Strategy weights
                            momentum_weight = gr.Slider(minimum=0, maximum=2, value=1.0, step=0.1, label="Momentum Weight")
                            mean_reversion_weight = gr.Slider(minimum=0, maximum=2, value=1.0, step=0.1, label="Mean Reversion Weight")
                            breakout_weight = gr.Slider(minimum=0, maximum=2, value=1.0, step=0.1, label="Breakout Weight")
                            volatility_weight = gr.Slider(minimum=0, maximum=2, value=0.8, step=0.1, label="Volatility Weight")
                    
                    # Portfolio Allocation
                    with gr.Accordion("Portfolio Allocation", open=True):
                        max_allocation = gr.Slider(minimum=0.01, maximum=1.0, value=0.5, step=0.01, 
                                                 label="Maximum Portfolio Allocation", 
                                                 info="Maximum percentage of portfolio to allocate to this strategy")
                        max_position_size = gr.Slider(minimum=0.01, maximum=0.5, value=0.1, step=0.01, 
                                                    label="Maximum Position Size", 
                                                    info="Maximum percentage of portfolio per position")
                    
                    # Risk Management
                    with gr.Accordion("Risk Management", open=True):
                        stop_loss = gr.Slider(minimum=0.01, maximum=0.2, value=0.05, step=0.01, 
                                            label="Stop Loss (%)", 
                                            info="Percentage below entry price to exit position")
                        take_profit = gr.Slider(minimum=0.01, maximum=0.5, value=0.15, step=0.01, 
                                              label="Take Profit (%)", 
                                              info="Percentage above entry price to exit position")
                        trailing_stop = gr.Checkbox(label="Use Trailing Stop", value=True)
                        allow_short = gr.Checkbox(label="Allow Short Positions", value=False)
                    
                    # Symbols to trade
                    symbols_input = gr.Textbox(
                        label="Symbols to Trade (comma-separated)", 
                        value="AAPL,MSFT,GOOG,AMZN",
                        info="Enter the symbols you want to trade"
                    )
                    
                    # Load from backtest results
                    load_from_backtest = gr.Checkbox(label="Load from Backtest Results", value=False)
                    
                    # Deploy button
                    deploy_btn = gr.Button("Deploy to Alpaca", variant="primary")
                
                with gr.Column(scale=1):
                    # Status and logs
                    deployment_status = gr.Textbox(label="Deployment Status", lines=3)
                    deployment_logs = gr.Textbox(label="Deployment Logs", lines=15)
            
            # Function to deploy strategy to Alpaca
            def deploy_to_alpaca(api_key, api_secret, paper_trading, strategy_type, 
                               momentum_enabled, mean_reversion_enabled, breakout_enabled, volatility_enabled,
                               momentum_weight, mean_reversion_weight, breakout_weight, volatility_weight,
                               max_allocation, max_position_size, stop_loss, take_profit, trailing_stop, allow_short,
                               symbols, load_from_backtest):
                try:
                    # Validate inputs
                    if not api_key or not api_secret:
                        return "Error: API Key and Secret are required", "Please provide valid Alpaca API credentials"
                    
                    if not symbols and not load_from_backtest:
                        return "Error: No symbols specified", "Please provide at least one symbol to trade or load from backtest results"
                    
                    # Process symbols
                    if load_from_backtest and screened_symbols_for_backtest:
                        # Load symbols from backtest results
                        symbol_list = []
                        for symbol in screened_symbols_for_backtest.split(","):
                            if ":short" in symbol:
                                # Extract the base symbol without the position type
                                base_symbol = symbol.split(":")[0]
                                symbol_list.append((base_symbol, "short"))
                            else:
                                symbol_list.append((symbol, "long"))
                        
                        # Format for display
                        symbol_display = ", ".join([f"{s[0]} ({s[1]})" for s in symbol_list])
                        position_types = {s[0]: s[1] for s in symbol_list}
                    else:
                        # Process manually entered symbols
                        symbol_list = [s.strip() for s in symbols.split(",")]
                        symbol_display = ", ".join(symbol_list)
                        position_types = {s: "long" for s in symbol_list}  # Default to long positions
                    
                    # Build strategy config
                    strategy_config = {
                        "type": strategy_type,
                        "parameters": {
                            "momentum_enabled": momentum_enabled,
                            "mean_reversion_enabled": mean_reversion_enabled,
                            "breakout_enabled": breakout_enabled,
                            "volatility_enabled": volatility_enabled,
                            "momentum_weight": momentum_weight,
                            "mean_reversion_weight": mean_reversion_weight,
                            "breakout_weight": breakout_weight,
                            "volatility_weight": volatility_weight,
                        },
                        "risk_management": {
                            "max_allocation": max_allocation,
                            "max_position_size": max_position_size,
                            "stop_loss": stop_loss,
                            "take_profit": take_profit,
                            "trailing_stop": trailing_stop,
                            "allow_short": allow_short
                        },
                        "symbols": symbol_list if not load_from_backtest else [s[0] for s in symbol_list],
                        "position_types": position_types if load_from_backtest else None,
                        "paper_trading": paper_trading
                    }
                    
                    # In a real implementation, this would call the Alpaca API
                    # For now, we'll just simulate a successful deployment
                    import json
                    import time
                    
                    # Log the deployment details
                    logs = f"Deploying strategy to Alpaca (Paper Trading: {paper_trading})\n"
                    logs += f"Strategy Type: {strategy_type}\n"
                    logs += f"Symbols: {symbol_display}\n"
                    logs += f"Risk Management: Stop Loss {stop_loss*100}%, Take Profit {take_profit*100}%\n"
                    logs += f"Max Allocation: {max_allocation*100}%, Max Position Size: {max_position_size*100}%\n"
                    logs += f"Allow Short: {allow_short}\n\n"
                    
                    # Simulate API call
                    logs += "Connecting to Alpaca API...\n"
                    time.sleep(1)  # Simulate API latency
                    logs += "Validating API credentials...\n"
                    time.sleep(1)  # Simulate API latency
                    logs += "Creating trading strategy...\n"
                    time.sleep(1)  # Simulate API latency
                    logs += "Setting up risk parameters...\n"
                    time.sleep(1)  # Simulate API latency
                    logs += "Deploying strategy to Alpaca...\n"
                    time.sleep(1)  # Simulate API latency
                    logs += "Strategy successfully deployed!\n"
                    
                    return "Success: Strategy deployed to Alpaca", logs
                    
                except Exception as e:
                    import traceback
                    error_details = traceback.format_exc()
                    return f"Error: {str(e)}", error_details
            
            # Wire up the deploy button
            deploy_btn.click(
                fn=deploy_to_alpaca,
                inputs=[
                    alpaca_api_key, alpaca_api_secret, alpaca_paper,
                    strategy_dropdown,
                    momentum_enabled, mean_reversion_enabled, breakout_enabled, volatility_enabled,
                    momentum_weight, mean_reversion_weight, breakout_weight, volatility_weight,
                    max_allocation, max_position_size,
                    stop_loss, take_profit, trailing_stop, allow_short,
                    symbols_input, load_from_backtest
                ],
                outputs=[deployment_status, deployment_logs]
            )
            

                    
        # Return the demo for launch
        return demo

if __name__ == "__main__":
    # Create and launch the UI
    demo = create_ui()
    # Launch with host set to 0.0.0.0 to be accessible from outside the container
    demo.launch(server_name="0.0.0.0", server_port=7860, share=False)
else:
    # For module import, provide a function to launch the UI
    def launch_gradio():
        demo = create_ui()
        demo.launch(server_name="0.0.0.0", server_port=7860, share=False)
